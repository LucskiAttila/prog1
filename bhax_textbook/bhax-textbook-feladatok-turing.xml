<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Turing!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
  <section>
    <title>Végtelen ciklus</title>
    <para>
      Írj olyan C végtelen ciklusokat, amelyek 0 illetve 100 százalékban dolgoztatnak egy magot és egy olyat, amely
      100 százalékban minden magot!
    </para>
    <para>

    </para>
    <para>
      <link xlink:href="https://github.com/vajkone/prog1/tree/master/batch1/feladat1">Megoldás forrása</link>
    </para>
    <para>

      100%-os mag használatot könnyen elérhetünk bármely egyszerű végtelen ciklussal, melynek végtelenségét
      az adja, hogy a ciklus futási feltételét úgy adjuk meg hogy az mindig igaz legyen. Erre számos megoldás
      létezik, pl: 
      <programlisting language="c"><![CDATA[
       int main(){

       while(1<2){;}

       return 0;
       }
       ]]>
    </programlisting>
    </para>
      <para>
        Ezzel az egyszerű programmal elérhetjük, hogy a programunk egy magot 100%-ban dolgoztasson meg.
        De mi van ha mi azt szeretnénk, hogy az összes magot 100%-ban használja ki? Nos, természetesen
        futtathatjuk a programot annyiszor ahány magunk van, vagy pedig segitségül hivhatjuk az OpenMP
        könyvtár szolgáltatásait.
        <programlisting language="c"><![CDATA[
        #include <stdio.h>
        #include <omp.h>

          int main(){

          #pragma omp parallel
          for(;;);
          return 0;
          }
          ]]>
        </programlisting>

        Ezt a kódot a gcc forditó -fopenmp kiegészitéssel ellátva forditjuk, majd futtatjuk.
        Ekkor láthatjuk, hogy az összes magunk (közel vagy ténylegesen) 100%-os terhelésen fut.

        <figure>
          <title>4 mag 100%-on</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="feladatok/batch1/feladat1/vegtelen1.png" format="PNG" scale="70"/>
            </imageobject>
          </mediaobject>
        </figure>
        

      </para>
        
      

    
    <para>
      Nézzük hát, hogy hogyan érhetnénk el azt, hogy egy olyan végtelen ciklust futtatunk ami 0%-ban használja a CPU-nkat.
      Nos, ezt a sleep() függvény segítségével fogjuk elérni. A sleep függvény ahogy neve is mutatja, altatja az adott
      programot paraméterként megadott másodpercnyi időre. Tehát, ha egy végtelen ciklusban sleep(1)-et alkalmazunk,
      a programunk folyamatosan aludni fog (ha csak ennyit tartalmaz a ciklus).
<programlisting language="c">
      <![CDATA[
      #include <unistd.h>
      int
      main (){

      for (;;)
      sleep (1);
      return 0;
      }
      
     ]]>
    </programlisting>
      
      <figure>
          <title>A programunk fut, de alszik</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="feladatok/batch1/feladat1/sleep.png" format="PNG" scale="70"/>
            </imageobject>
          </mediaobject>
        </figure>


  </para>

  </section>        
        
    <section>
        <title>Lefagyott, nem fagyott, akkor most mi van?</title>
        <para>
            Mutasd meg, hogy nem lehet olyan programot írni, amely bármely más programról eldönti, hogy le fog-e fagyni vagy sem!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  tegyük fel, hogy akkora haxorok vagyunk, hogy meg tudjuk írni a <function>Lefagy</function>
            függvényt, amely tetszőleges programról el tudja dönteni, hogy van-e benne vlgtelen ciklus:              
        </para>
        <programlisting language="c"><![CDATA[Program T100
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	main(Input Q)
	{
		Lefagy(Q)
	}
}]]></programlisting>            
        <para>
            A program futtatása, például akár az előző <filename>v.c</filename> ilyen pszeudókódjára:
            <screen><![CDATA[T100(t.c.pseudo)
true]]></screen>            
            akár önmagára
            <screen><![CDATA[T100(T100)
false]]></screen>  
            ezt a kimenetet adja.          
        </para>
        <para>
            A T100-as programot felhasználva készítsük most el az alábbi T1000-set, amelyben a
            Lefagy-ra épőlő Lefagy2 már nem tartalmaz feltételezett, csak csak konkrét kódot:
        </para>
        <programlisting language="c"><![CDATA[Program T1000
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	boolean Lefagy2(Program P)
	{
		 if(Lefagy(P))
			return true;
		 else
			for(;;); 
	}

	main(Input Q)
	{
		Lefagy2(Q)
	}

}]]></programlisting>            
        <programlisting><![CDATA[]]></programlisting>            
        <para>
            Mit for kiírni erre a <computeroutput>T1000(T1000)</computeroutput> futtatásra?
                                
            <itemizedlist>
                <listitem>
                    <para>Ha T1000 lefagyó, akkor nem fog lefagyni, kiírja, hogy true</para>                        
                </listitem>
                <listitem>
                    <para>Ha T1000 nem fagyó, akkor pedig le fog fagyni...</para>                        
                </listitem>
            </itemizedlist>
            akkor most hogy fog működni? Sehogy, mert ilyen <function>Lefagy</function>
            függvényt, azaz a T100 program nem is létezik.                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
      <para>

        Ha a program olyan programot kap bemenetként melyben van végtelen ciklus akkor akkor visszaad
        egy igaz értéket a T1000es programnak, ami ekkor boldogan leáll és kiirja, hogy igen itt bizony
        végtelen ciklus van. Ha viszont a vizsgált programban nincs végtelen ciklus akkor ő maga fog
        végtelen ciklusba kerülni. Ebből már rögtön érzékelhetjük, hogy mi is lesz a gond ha saját magát
        kell ilyen módon elemeznie.
      </para>
      <para>
        True: megáll, azaz végtelen ciklust talált, de ezekszerint nem áll le, de hogyha meg nem áll le,
        akkor pedig újabban ismét végtelen ciklust talál, tehát leáll - de ha leáll akkor mégsem végtelen?
        És igy tovább...
        Elsőre az embernek kicsit nehéz lehet ezt értelmezni, de a paradoxonokkal gyakran van ez igy.
        A lényeg, hogy ilyen programot lehetetlen irni.
      </para>
    </section>        
                
    <section>
        <title>Változók értékének felcserélése</title>
        <para>
            Írj olyan C programot, amely felcseréli két változó értékét, bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk">https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/vajkone/prog1/tree/master/feladatok/batch1/swap">https://github.com/vajkone/prog1/tree/master/feladatok/batch1/swap</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
      <para>
        A legegyszerűbb megoldás erre a problémára egy segédváltozó használata. Ezt a módszert szemléltetni
        úgy lehet a legkönyebb ha a változókra poharakként, a bennünk tárolt értékekre pedig int viz gondolunk.
        Hogyan tudjuk hát 2 teli pohár tartalmát egyikből a másikba önteni? Természetesen egy harmadik,
        üres pohár segitségével:

        <programlisting language="c">
        <![CDATA[
        int a=10;
        int b=7;
        int c;
        
        c=a; //c=10
        a=b; //a=7
        b=c; //b=10
            
        ]]>
      </programlisting>
        
        
         
      </para>

      <para>
        A dolgot természetesen matematikai szempontból is meg lehet közeliteni. Ha összeadjuk a két
        változót majd a kapott összegből kivonjuk a régi értéküket akkor megkapjuk hogy mi volt a másik
        változó értéke amit hozzáadtunk, azaz amivel cserélni akarjuk. Ez a gyakorlatban igy néz ki:

        <programlisting language = "c">
          <![CDATA[
                int a = 9;
                int b = 7;
                a = a+b; //a=18
                b = a-b; //b=9
                a = a-b; //a=7
            ]]>
        </programlisting>
      </para>

        <para>
          Létezik ugyancsak egy másik megoldás amihez szintén kell matematikai logika viszont már közelebb
          áll az informatika szakterületéhez, ez pedig nem más mint a XOR azaz a kizáró vagy logikai művelet
          és az ezzel való csere.
          A számitógép az általunk deklarált voltozók (meg úgy minden szám) értékét 2-es számrendszerrű
          számként értelmezi és tárolja. Igy például az előző példában használt 7-es és 9-es igy néznének ki:
          7: 0111, 9: 1001. Most hogy ezt tisztáztuk érthetőbb lesz, ha aztmondjuk hogy a XOR művelet
          1-est ad vissza mindenhol az vagy az egyik vagy a másik szám bináris értékében 1-es szerepel,
          de nem mindkettőében. Ez a gyakorlatban igy néz ki:

          <programlisting language = "c">
            <![CDATA[
                int a = 7; //binárisan: 0111
                int b = 9; //binárisan: 1001
                a = a^b; //a= 0111 ^ 1001 = 1110
                b = a^b; //b= 1110 ^ 1001 = 0111
                a = a^b; //a= 1110 ^ 0111 = 1001
            ]]>
          </programlisting>



        </para>

      
    </section>                     

    <section>
        <title>Labdapattogás</title>
        <para>
            Először if-ekkel, majd bármiféle logikai utasítás vagy kifejezés
            használata nélkül írj egy olyan programot, ami egy labdát pattogtat a karakteres konzolon! (Hogy mit értek
            pattogtatás alatt, alább láthatod a videókon.)
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/labdapattogas">https://bhaxor.blog.hu/2018/08/28/labdapattogas</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/vajkone/prog1/tree/master/feladatok/batch1/labdapattog">https://github.com/vajkone/prog1/tree/master/feladatok/batch1/labdapattog</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
      <para>
        A labdapattogás nem több mint a terminálon belüli, valamilyen karakter (ha már labda akkor legyen
        O ), X Y tengelyen való eltolását jelenti. Ha a labda falhoz ér, azaz x vagy y értékünk 0 lesz,
        akkor pedig visszapattan. De honnan tudja a labda, hogy a terminálunk fala hol is van? Ebben
        segit nekunk ez a kód részlet:
        <programlisting language="c">
          <![CDATA[
                WINDOW *ablak;
                ablak = initscr ();
            ]]>
        </programlisting>


        <programlisting language="c">
          <![CDATA[
          
        int x = 0;
        int y = 0; 

        int deltax = 1; 
        int deltay = 1; 
   

        int mx; 
        int my; 
        ]]>
        </programlisting>

        X és y a labdánk kiinduló poziciója lesz, deltax és deltay pedig a lépésszámot fogja meghatározni az adott tengelyeken.
        Mx és my változók pedig az ablakunk szélességét és hosszát fogják reprezentálni (oszlopok és sorok száma az ablakunkban).
        
      </para>
      <para>
        <programlisting language="c">
          <![CDATA[
       

        for ( ;; ) { 
        getmaxyx ( ablak, my , mx ); 
        mvprintw ( y, x, "O" ); 
        refresh ();
        usleep ( 100000 ); 
        clear() 
        
        ]]>

        </programlisting>

        Kezdünk egy, a már korábbi programokból is ismert for ciklussal ami jól látszik hogy a végtelenségik fog futni. A
        getmaxyx(ablak, my , mx ) függvénynek átadjuk az ablakunk hosszát és szélsességét, a mvprintw ( y, x, "O" )
        függvény pedig y és x koordinátákra fogja rajzolni az 'O' karaktert, azaz a labdánkat.
        Az usleep() függvény a sleep()-el ellentétben nem másodpercekre, hanem mikroszekundumnyi időre altatja a programunkat,
        ezzel befolyásolva a labda mozgásának sebességét. A clear() függvény opcionális, ha kikommenteljük akkor a labdánk csíkot
        húz, azaz az előző kirazjolt labdánk nem fog eltűnni.
      </para>

      <para>

        <programlisting language="c">
          <![CDATA[

              x = x + deltax; 
              y = y + deltay; 

              if ( x>=mx-1 ) {             
              deltax = deltax * -1;       
              }
              if ( x<=0 ) {                
                  deltax = deltax * -1;    
              }
              if ( y<=0 ) {                
                  deltay = deltay * -1;    
              }
              if ( y>=my-1 ) {             
                  deltay = deltay * -1;    
              }

          }

          return 0;
      }
          
          
          ]]>

        </programlisting>
        Itt történik meg a pozícióváltás, deltax és deltay-nal növeljük, változtatjuk a labda következő kirajzolandó helyzetét.
        Ezután pedig megvizsgáljuk, hogy a labda így elérte-e az ablakunk széleit (mx és my), ha igen, akkor deltax és/vagy deltay
        előjelét megváltoztatjuk, hogy ezután, hogyha hozzádjuk őket a jelenlegi x és y pozíciókhoz, akkor ellentétes irányba 
        menjenek mint eddig, azaz a labdánk pattanjon vissza a falról. 
        
        
        
        

      </para>

      <para>
        
        Az if nélküli megoldáshoz ismét a matematika csodálatos tudományát hivjuk segitségül, mégpedig nem
        mást mint a maradékos osztást...
        
      </para>
      
      
    </section>                     

    <section>
        <title>Szóhossz és a Linus Torvalds féle BogoMIPS</title>
        <para>
            Írj egy programot, ami megnézi, hogy hány bites a szó a gépeden, azaz mekkora az <type>int</type> mérete.
            Használd ugyanazt a while ciklus fejet, amit Linus Torvalds a BogoMIPS rutinjában! 
        </para>
        <para>
            Megoldás videó: <link xlink:href=""></link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/vajkone/prog1/tree/master/feladatok/batch1/szohossz">https://github.com/vajkone/prog1/tree/master/feladatok/batch1/szohossz</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... 
        </para>
      <para>
        
        Először is: mi is az a szóhossz az informatikai zsargonban? Ez nem más mint a számitógépünk 
        által, adatok ábrázolása és átvitele közben alkalmazott elemi egység. A BogoMips pedig egy Linus
        Torvalds által irt program mely a CPU-nk gyorsaságát hivatott mérni. Persze ez nem ér fel egy 
        CPU stretch test-tel, de diákok számára kiváló versenyt biztosithat, hogy kinek fut le gyorsabban.
        A BogoMips-ből átemeljük a while ciklust, melyben a másodpercenkénti loop-ot egy másik változóval
        helyettesitjuk. Ez a változó fogja mérni a bitek számát. A tényleges szóhosszt bitshifteléssel
        fogjuk kideriteni. Addig lépkedünk balra, amig csupa nullába nem botlunk, eközben a lépseinket
        számolja a már korábban emlitett változónk, amit a while ciklusból kilépve kiirunk és megkapjuk
        hogy hány bites a szóhossz a gépünkben. 
      </para>
    </section>                     

    <section>
        <title>Helló, Google!</title>
        <para>
            Írj olyan C programot, amely egy 4 honlapból álló hálózatra kiszámolja a négy lap Page-Rank 
            értékét!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""></link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/vajkone/prog1/tree/master/feladatok/batch1/pagerank">https://github.com/vajkone/prog1/tree/master/feladatok/batch1/pagerank</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
      <para>
        A Google keresője mára vitathatatlanul a legnépszerűbb kereső motorrá nőtte ki magát. De minek 
        köszönheti népszerűségét? Néha az az érzésünk támadhat, hogy a Google kereső jobban tudja, hogy mit 
        is akarunk mint mi magunk. (Néha mikor még a fejemben se állt össze, hogy mire is szeretnék
        rákeresni, a google már ki is hozta mint első javaslat. Hát már ilyen szintent megfigyelnek minket?!)
        Hogyan lett hát a google keresője ilyen kifinomult? Nos, a kereső algoritmus egyik, ha nem a
        legonfontosabb része / funkciója a PageRank rendszer. Ez az az algoritmus mely eldönteni, hogy egyes
        lapok mennyire elől szerepeljenek a találatok közötti listában. Személy szerint nem emlékszem, 
        hogy a közelmúltban bármikor is a találatok 2. oldalára kellett volna kattintanom, hogy megtaláljam
        amit keresek, szóval úgy vélem nagy biztonsággal kijelenthetjük, hogy a google PageRank algoritmusa
        jól végzi a dolgát. De hogyan is teszi mindezt?
        
      </para>
      <para>
        
        A PageRank bizonyos pontrendszerrel dolgozik. Ezeket a pontokat részben azért kaphatja egy oldal,
        hogyha más oldalakról rá mutatnak (linkek). Logikus, hiszen jobb minőségű oldalakra nyilván több
        link fog mutatni, mint egy gagyi oldalra. Ezek a linkek ún. szavazatoknak számitanak és nem egyenlő
        erősségűek. Magasabb pontszamú oldalak szavazatai értéksebbek, mint gyengébb pontszámú társaiké.
        Egy oldal "szavazó-ereje" annál gyengébb minél több külső helyre mutat. Ez részben azt eredményezi, hogy
        az oldalak tényleg csak olyan oldalra fognak mutatni, akit arra érdemesnek tartanak.
        
      </para>
    </section>

    <section xml:id="Brun">
        <title>100 éves a Brun tétel</title>
        <para>
            Írj R szimulációt a Brun tétel demonstrálására!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/xbYhp9G6VqQ">https://youtu.be/xbYhp9G6VqQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R</link>
        </para>
      <para>
        A Brun tétel és a Brun szám Viggo Brun, norvég fizikus nevéhez kötődik. A tétel azt mondja ki
        hogy az ikerprimek reciprokösszege egy bizonyos összeghez konvergál, azaz azt tetszőlegesen
        megközeliti, de el nem éri. Ezt a számot nevezik Brun konstansnak. Egyelőre csak becslések léteznek
        arról, hogy ez a szám mekkora is, de a szakemberek valahol 1,9 és 2,1754 közé tippelik.

      </para>
    </section>
    
    <section xml:id="bhax-textbook-feladatok-turing.MontyHall">
        <title>A Monty Hall probléma</title>
        <para>
            Írj R szimulációt a Monty Hall problémára!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan">https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
      <para>
        Kezdjük azzal, hogy mi is az a Monty Hall probléma?
      </para>
      <para>

        Ön játékos egy televíziós műsorban, és három ajtó közül kell választania.  
        Az egyik mögött rejlik a főnyeremény, egy autó, a másik kettő mögött pedig nincs semmi.
        Ön a második ajtót választja. Ekkor a műsorvezető kinyitja a másik két ajtó közül az egyiket, 
        mondjuk a harmadikat, ami üres. Majd felteszi a kérdést, hogy szeretne-e változtatni és 
        esetleg  másik ajtót választani?
      </para>
      <para>
        
      </para>
    </section>

</chapter>                
