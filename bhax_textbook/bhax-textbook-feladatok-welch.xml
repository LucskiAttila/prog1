<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Welch!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Első osztályom</title>
        <para>
            Valósítsd meg C++-ban és Java-ban az módosított polártranszformációs algoritmust! A matek háttér 
            teljesen irreleváns, csak annyiban érdekes, hogy az algoritmus egy számítása során két normálist
            számol ki, az egyiket elspájzolod és egy további logikai taggal az osztályban jelzed, hogy van vagy
            nincs eltéve kiszámolt szám.
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... térj ki arra is, hogy a JDK forrásaiban a Sun programozói
            pont úgy csinálták meg ahogyan te is, azaz az OO nemhogy nem nehéz, hanem éppen természetes neked!
        </para>
      <para>
        <programlisting language = "c">
          <![CDATA[
                
                class Random {

	                public:
		                Random();
		                ~Random(){} 
		                double get(); 

	                private:
		                bool exist; 
		                double value; 

                };

                
            ]]>
        </programlisting>
        
        Létrehozzuk a Random nevű osztályt, melynek elemeit két részre osztjuk: publikus, azaz a class-on
        kivűl is láthatóak/elérhetőek, valamint privát, mely elemeknek elérése a classon belülre korlátozódik.
        A public részben létrehozunk egy kontstruktort és egy destruktort. Nevükből értelemszerűen adódik,
        hogy az egyik az objektumok létrehozását végzi, másik pedig az eltakaritásukat. A get fügvényünk-kel
        pedig lekérjük, hogy mit is generáltunk. Privát állományunkba kerül egy bool ami vizsgálja, hogy van-e
        már korábbi ilyen érték, amit pedig a value-ban tárolunk.
        

      </para>
      <para>
        <programlisting language = "c">
          <![CDATA[
                
              double Random::get() { 
	            if (!exist)
	            {
		            double u1, u2, v1, v2, w;
	
		            do{

			            u1 = std::rand () / (RAND_MAX + 10.0); 
			            u2 = std::rand () / (RAND_MAX + 1.0);
			            v1 = 2 * u1 - 1;
			            v2 = 2 * u2 - 1;
			            w = v1 * v1 + v2 * v2;
		                }
		            while (w > 1);

		            double r = std::sqrt ((-2 * std::log (w)) / w);

		            value = r * v2; 
		            exist = !exist;
		            return r * v1; 
	            }
	
	            else
	            {	
		            return value;
		            exist = !exist;
	            }
            };    
  
                
            ]]>
        </programlisting>
        
        Az algoritmus 2 random számot generál, az egyiket eltárolja a value-ban, a másikat pedig visszaadja
        a get() függvény. A value-ban lévőt akkor adja vissza, ha az exist igaz, magyarul már van korábbi
        random érték.
        
      </para>
      <para>
        <programlisting language = "c">
          <![CDATA[
                
           int main() 
            {
	            Random rnd;

	            for (int i = 0; i < 10; ++i) 
		            std::cout << rnd.get() << std::endl; 


            }
                
            ]]>
        </programlisting>
        Végül generálunk 10 darab random számot. 
        
        
      </para>

      <para>
        Ugyanez Javaban:

        <programlisting language = "c">
          <![CDATA[
                
  public class PolarGen	{

  public final  static int RAND_MAX = 32767;
  private static boolean bExists;
  private double dValue;
  static Random cRandomGenerator = new Random();
  

  public PolarGen() { 
	bExists = false;
	cRandomGenerator.setSeed(20);
  };
  
  public double PolarGet()	{
    	if (!bExists)
  {
		double u1, u2, v1, v2, w;

		do{
			u1 = cRandomGenerator.nextInt (RAND_MAX) / (RAND_MAX + 1.0);
			u2 = cRandomGenerator.nextInt (RAND_MAX) / (RAND_MAX + 1.0);
			v1 = 2 * u1 - 1;
			v2 = 2 * u2 - 1;
			w = v1 * v1 + v2 * v2;
		    }
		while (w > 1);

		double r = Math.sqrt ((-2 * Math.log (w)) / w);

		dValue = r * v2; 
		bExists = !bExists;

		return r * v1; 
	}
	
	else
	{
		bExists = !bExists; 
		return dValue;
	}
  };    
  
  public static void main(String args[])	{
    PolarGen cPolarGen = new PolarGen();
    double  dEredmeny = cPolarGen.PolarGet();
    System.out.println(dEredmeny);
  }
  
}
                
            ]]>
        </programlisting>
        
        Annyi változás van (a nyelvspecifikus szintaktikát leszámitva), hogy itt minden a PolarGen osztályon
        belűlre kerül, még a main függvényünk is. 
        
      </para>
    </section>        

    <section>
        <title>LZW</title>
        <para>
            Valósítsd meg C-ben az LZW algoritmus fa-építését!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
      <para>
        Kis történelmi kitekintés: Lempel–Ziv–Welch, azaz LZW egy univerzális adatvesztés nélkül járó
        tömöritési eljárás, melyet Abraham Lempel, Jacob Ziv és Terry Welch készitett. Az algoritmus közkedvelt
        egyszerű  implementálhatóságának hála. A Unix rendszerek file-ok tömöritése esetén valamint
        a GIF képfájlok is ezt az algoritmust használják, de mára a PNG már képformátum már elterjedtebb.

      </para>
    </section>        
        
    <section>
        <title>Fabejárás</title>
        <para>
            Járd be az előző (inorder bejárású) fát pre- és posztorder is!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
    </section>        
                        
    <section>
        <title>Tag a gyökér</title>
        <para>
            Az LZW algoritmust ültesd át egy C++ osztályba, legyen egy Tree és egy beágyazott Node
            osztálya. A gyökér csomópont legyen kompozícióban a fával!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:                
        </para>
    </section>        
                
    <section>
        <title>Mutató a gyökér</title>
        <para>
            Írd át az előző forrást, hogy a gyökér csomópont ne kompozícióban, csak aggregációban legyen a 
            fával!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása:  
        </para>
    </section>                     

    <section>
        <title>Mozgató szemantika</title>
        <para>
            Írj az előző programhoz mozgató konstruktort és értékadást, a mozgató konstruktor legyen a mozgató
            értékadásra alapozva!
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása:  
        </para>
    </section>                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
