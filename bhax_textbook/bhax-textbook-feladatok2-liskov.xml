<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Liskov!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Liskov helyettesítés sértése</title>
        <para>
          A Liskov helyettesítési elv (Liskov Substitution Principle - LSP) egy koncepció az Objektum Orientált programozásban, amely
          azt mondja ki hogy ha egy S altípusa T-nek, akkor minden olyan helyen ahol T-t felhasználjuk
          S-t is minden gond nélkül behelyettesíthetjük anélkül,
          hogy a programrész tulajdonságai megváltoznának.
          
        <figure>
         <title>Liskov helyettesítési elv</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="../Prog2Liskov/liskov.jpg" format="JPG" scale="70"/>
            </imageobject>
          </mediaobject>
        </figure>
          
          
        </para>
      <para>
        Ezt az elvet és annak sértését nagyon könnyen lehet szemlélteni akár valódi életből kiragadott példákkal is. Például:

        <programlisting language = "Java">
          <![CDATA[
          
          public class Madarak{
              public void repul(){}
          }
          
          public class Kacsa extends Madarak{}
          
            ]]>
        </programlisting>

        Eddig ügye semmi probléma, van egy Madarak osztályunk amiben van egy Repül nevezetű funkciónk és azt mondjuk, hogy a Kacsa osztály
        a Madarak osztály leszármazottja. A gondok az ilyen eseteknél kezdődnek:

        <programlisting language = "Java">
          <![CDATA[ 
          
        public class Strucc extends Madarak{}
        
           ]]>
        </programlisting>
        A strucc az madár, viszont repülni nem tud, így megszegjük a Liskov helyettesítési elvet. Egy megoldás: jobb OO tervezés, szükség
        esetén pontosabb specifikálás.

        <programlisting language = "Java">
          <![CDATA[ 
          
            public class Madarak{
            }
            public class RepuloMadarak extends Madarak{
                public void fly(){}
            }
            public class Kacsa extends RepuloMadarak{}
            public class Strucc extends Madarak{} 
          
          
           ]]>
        </programlisting>
        
        
        
      </para>
      
      
    </section>

  <section>
    <title>Szülő-gyerek</title>
    <para>
      
      A feladat szerint olyan osztálydefiníciót kell írni, amelyben demonstráljuk, hogy a szülőn keresztül
      nem küldhető a gyerek üzenete, csak a sajátja. 

    </para>

    <para>

      <figure>
        <title>A szülő nem tudja a gyerek üzenetét küldeni</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../Prog2Liskov/szulogyerek.png" format="PNG" scale="70"/>
          </imageobject>
        </mediaobject>
      </figure>


      <figure>
        <title>A szülő a saját üzenetét minden gond nélkül elküldi</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../Prog2Liskov/szulogyerek2.png" format="PNG" scale="70"/>
          </imageobject>
        </mediaobject>
      </figure>

    </para>
    
    
  </section>

  <section>
    <title>Anti OO</title>
    <para>
      A már korábban vizsgált BBP algoritmussal kellett dolgozni ebben a feladatban is. A Pi hexadecimális kifejtésének
      a 0. pozíciótól számított 10^6, 10^7 és 10^8-on jegyét kellett C, Java és C# nyelven meghatározni és ezen különböző
      nyelvekek az algoritmus futási idejét összevetni. Ez a feladat akár egy kis házibajnokságként is megállná a helyét.
      Az én esetemben a Java nyelv volt a leggyorsabb, ami nagy meglepetésemre szolgált ugyanis azt tettem volna utolsó helyre,
      előzetes vizsgálódásaim miatt pedig a C#-ot az elsőre, ami pedig pont hogy utolsóként végzett nálam. A CPU-m:
      AMD RYZEN 5 3600X 6-Core 3.8 GHz.
      Lássuk akkor az eredményeket:


    </para>

    <para>
      <figure>
        <title>Java Pi Bench 10^6</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../Prog2Liskov/PiBenchJava6.png" format="PNG" scale="100"/>
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>Java Pi Bench 10^7</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../Prog2Liskov/PiBenchJava7.png" format="PNG" scale="100"/>
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>Java Pi Bench 10^8</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../Prog2Liskov/PiBenchJava8.png" format="PNG" scale="100"/>
          </imageobject>
        </mediaobject>
      </figure>
      
      Láthatjuk, hogy Java nyelven még a 10^8-on számot is elég gyorsan kiszámolta, ezzel szemben a C# már kicsit tovább 
      tartott. Lássuk is: 
  
    </para>

    <para>
      <figure>
        <title>C# Pi Bench 10^6</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../Prog2Liskov/PiBenchCS6.png" format="PNG" scale="100"/>
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>C# Pi Bench 10^7</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../Prog2Liskov/PiBenchCS7.png" format="PNG" scale="100"/>
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>C# Pi Bench 10^8</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../Prog2Liskov/PiBenchCS8.png" format="PNG" scale="100"/>
          </imageobject>
        </mediaobject>
      </figure>
      
      
    </para>

    <para>

      A C nyelv egészen korrektül szerepelt annak ellenére, hogy én VirtualBox-ból futtatott Linuxon teszteltem, így
      nem volt hozzáférése a CPU és RAM teljes erőforrásaihoz.

      <figure>
        <title>C Pi Bench 10^6</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../Prog2Liskov/pibenchC6.png" format="PNG" scale="70"/>
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>C Pi Bench 10^7</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../Prog2Liskov/pibenchC7.png" format="PNG" scale="70"/>
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>C Pi Bench 10^8</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../Prog2Liskov/pibenchC8.png" format="PNG" scale="70"/>
          </imageobject>
        </mediaobject>
      </figure>

    </para>
  </section>

  <section>
    <title>Hello, Android!</title>
    <para>

    </para>
  </section>

  <section>
    <title>Ciklomatikus komplexitás</title>
    <para>
      
      A ciklomatikus komplexitás egy olyan mérőszám amely a programok komplexitását hívatott leírni. 
      A forráskód komplexitását az elágazások fogják befolyásolni és a belőlük felépíthető gráf pontjai,
      de ebbe most ne menjünk jobban bele. 

    </para>

    <para>
      Én az LZWBinfa java verziójának komplexitását vizsgáltam meg és egy egyszerű de nagyszerű online tool-t használtam.
      <link xlink:href="http://www.lizard.ws">Ezen</link> az oldalon mindössze annyi a teendőnk, hogy a vizsgálni kívánt forráskódot bemásoljuk
      a megfelelő helyre és analizáljuk azt. 
      
    </para>

    <para>

      <figure>
        <title>Az LZWBinFa.java komplexitása </title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../Prog2Liskov/complexity.png" format="PNG" scale="70"/>
          </imageobject>
        </mediaobject>
      </figure>
      
    </para>
  </section>
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
