<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Arroway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>OO szemlélet</title>
      
        <para>

          A polártranszformációs generátor működésének az alapelgondolása a következő: Először is tárol egy logika változót és tud tárolni
          egy értéket. A logika változó értéke azt hivatott reprezentálni, hogy éppen van-e tárolt érték vagy nincs. Ha nincs tárolt érték
          akkor generálunk, de nem is egyet hanem rögtön két pseudo random számot. Az egyik a függvényünk visszatérési értéke lesz a másik pedig a tárolt
          érték, amit legközelebb már visszatudunk majd adni ha újabb avagy több random számra van szükségünk. Az algoritmus így néz ki: 

        </para>
      
      <para>
        <programlisting language = "Java">
          <![CDATA[
          
      public class PolarGenerator {

          private static boolean vanTarolt;
          private double taroltErtek;

          public PolarGenerator() {
              vanTarolt = false;

          }

          public double generate() {
              if (!vanTarolt)
              {
                  double u1, u2, v1, v2, w;

                  do{
                      u1 = random();
                      u2 = random();
                      v1 = 2 * u1 - 1;
                      v2 = 2 * u2 -1;
                      w = v1 * v1 + v2 * v2;
                  }
                  while (w > 1);

                  double r = Math.sqrt ((-2 * Math.log (w)) / w);

                  taroltErtek = r * v2;
                  vanTarolt = !vanTarolt;

                  return r * v1;
              }

              else
              {
                  vanTarolt = false;
                  return taroltErtek;
              }
          }

      }
   
           ]]>
        </programlisting>
        
      </para>

      <para>
        Ezután a main függvényünkben példányosítunk és futtatjuk, jelen esetben 15 random számot generálva.

        <programlisting language = "Java">
          <![CDATA[
          
          public static void main(String[] args) {
        
              for (int i=0;i<15;i++) {
                  PolarGenerator PolarGen = new PolarGenerator();
                  double random= PolarGen.generate();
                  System.out.println(random);
              }
        

          }
          
           ]]>
        </programlisting>

        <figure>
          <title>Futtatás eredménye</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="../Prog2Arroway/generate.png" format="PNG" scale="90"/>
            </imageobject>
          </mediaobject>
        </figure>
        
        
      </para>

      <para>
        A mi Polárgenerátorunk lényegében ugyanaz mint a Java nextGaussian() nevű függvénye. A hivatalos Oracle dokumentációban elolvashatjuk
        hogy ez is a "polar methodust" használja: "This uses the polar method of G. E. P. Box, M. E. Muller, and G. Marsaglia,
        as described by Donald E. Knuth in The Art of Computer Programming, Volume 3: Seminumerical Algorithms,
        section 3.4.1, subsection C, algorithm P. Note that it generates two independent values at the cost
        of only one call to StrictMath.log and one call to StrictMath.sqrt."

        <figure>
          <title>nextGaussian</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="../Prog2Arroway/nextGaussian.png" format="PNG" scale="70"/>
            </imageobject>
          </mediaobject>
        </figure>

      </para>
        
    </section>        

    <section>
        <title>Homokozó</title>
        <para>
          
        </para>
      <para>
        
      </para>
    </section>

  <section>
    <title>Gagyi</title>
  
    <para>

      Hogy megértsük, hogy hogyan is működik az Integer típus és hogy miért is érdekes ez a feladat, érdemes először is egy pillantást
      vetni az Integer osztály valueOf() nevű függvényének dokumentációjára:
      <literallayout>

public static Integer valueOf(int i)

Returns an Integer instance representing the specified int value. If a
new Integer instance is not required, this method should generally be 
used in preference to the constructor Integer(int), as this method is 
likely to yield significantly better space and time performance by
caching frequently requested values. This method will always cache values in the 
range -128 to 127, inclusive, and may cache other values outside of this range. 
        
Parameters: 
i - an int value.
        
Returns:
an Integer instance representing i.
        
      </literallayout>


    </para>

    <para>
      <programlisting language = "Java">
          <![CDATA[

      Integer x,t;

      Scanner sc = new Scanner(System.in);

      System.out.print("Value of x: ");
      x=sc.nextInt();

      System.out.print("Value of t: ");
      t=sc.nextInt();

      while (x <= t && x >= t && t != x){

      }
      
        ]]>
    </programlisting>


    </para>
    
  </section>

  <section>
    <title>Yoda</title>

    <para>

    </para>

  </section>

  <section>
    <title>Kódolás from scratch</title>

    <para>

    </para>

  </section>


</chapter>                
