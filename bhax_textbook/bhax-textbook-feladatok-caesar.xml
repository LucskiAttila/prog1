<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Caesar!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title><type>double **</type> háromszögmátrix</title>
        <para>
           
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  <link xlink:href="https://github.com/vajkone/prog1/blob/master/caesar/matrix.c">https://github.com/vajkone/prog1/blob/master/caesar/matrix.c</link>              
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>  
        <para>
            A háromszögmátrixok olyan négyzetes mátrixok (mátrixok melyeknek sorainak és oszlopainak száma
            megegyeznek), melyeknek a főátló alatti vagy feletti értékei csupa nullák. Egy ilyen mátrixban
            a determináns kiszámitása is pofon egyszerű, hiszen csak a főátlóban lévő számokat kell összeszorozni.
            
        </para>
      <para>
        Mi most egy alsó háromszögmátrixot fogunk létrehozni, ami azt jelenti, hogy a főátló felett lesznek
        a nullák.
        
      </para>
      <para>
        <programlisting language = "c">
          <![CDATA[
    int nr = 5;
    double **tm;
    
    printf("%p\n", &tm);
    
    if ((tm = (double **) malloc (nr * sizeof (double *))) == NULL)
    {
        return -1;
    }

    printf("%p\n", tm);
    
    for (int i = 0; i < nr; ++i)
    {
        if ((tm[i] = (double *) malloc ((i + 1) * sizeof (double))) == NULL)
        {
            return -1;
        }

    }
            ]]>
        </programlisting>
        Az nr-ben tároljuk, hogy mekkora mátrixot szeretnénk, ez a mostani egy 5x5-ös lesz.
        Ezután ellenőrizzük, hogy a malloc által lefoglalt memória területünk NULL-ra mutató pointert ad-e vissza,
        (pl nincs memória) ha igen akkor hibába ütköztünk és kilép a programból.
      </para>
      <para>
        <programlisting language = "c">
          <![CDATA[
      for (int i = 0; i < nr; ++i)
        for (int j = 0; j < i + 1; ++j)
            tm[i][j] = (i * (i + 1) / 2 + j)+1;
            
         for (int i = 0; i < nr; ++i)
        {
        for (int j = 0; j < i + 1; ++j)
            printf ("%f, ", tm[i][j]);
        printf ("\n");
        }     
            ]]>
        </programlisting>
    
        Itt értek adunk a mátrix elemeinek, 1-től kezdve iterálva, majd ki is irjuk a mátrixot.
      </para>
      <para>
        <programlisting language = "c">
          <![CDATA[
    
    tm[3][0] = 42.0;
    (*(tm + 3))[1] = 43.0;	
    *(tm[3] + 2) = 44.0;
    *(*(tm + 3) + 3) = 45.0;

    for (int i = 0; i < nr; ++i)
    {
        for (int j = 0; j < i + 1; ++j)
            printf ("%f, ", tm[i][j]);
        printf ("\n");
    }

    for (int i = 0; i < nr; ++i)
        free (tm[i]);

    free (tm);
   
            ]]>
        </programlisting>

        Itt különböző módokon adunk értéket a 4. sor elemeinek. A tm[s][o] mátrixban az s a sor számát az o pedig az oszlopét
        jelöli. A program végén, mikor már nincs rá szükségünk, a free() függvénnyel felszabaditjuk a 
        a mátrix számára lefoglalt memóriát. 
      </para>
    </section>        
    <section>
        <title>C EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót C-ben!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/vajkone/prog1/blob/master/caesar/exortitkosit.c">https://github.com/vajkone/prog1/blob/master/caesar/exortitkosit.c</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
      <para>
        A titkositáshoz szükségünk lesz egy titkositando szövegre és egy kulcsra, valamint az elvre ami
        alapján a szöveget titkositjuk. Jelen esetben ez az elv a XOR logikai művelet által biztositott
        lehetőségeken fog alapulni. Korábban már használtuk a kizáró vagyot 2 érték felcserélésekor, most
        megnézzük, hogyan tudjuk titkositáshoz használni.
        
      </para>
      <para>
        <programlisting language = "c">
          <![CDATA[
          
          #define MAX_KULCS 100
          #define BUFFER_MERET 256
          
          int main (int argc, char **argv)
          {
          char kulcs[MAX_KULCS];
          char buffer[BUFFER_MERET];

          int kulcs_index = 0;
          int olvasott_bajtok = 0;
 
   
            ]]>
        </programlisting>

        Konstansként definiáljuk a max_kulcsot és a buffer_meret-et. Ezek értéke a későbbiekben már
        nem változtatható. A main függvényünk most a szokásostól eltérően kap 2 argumentumot, ezekre azért
        van szükség mert a kódolandó szöveget és kulcsot parancssorból fogja megkapni. Ezek után létrehozzuk
        a kulcs tömbünket (melynek mérete definició szerint 100) és a buffer tömbünket melybe a beolvasott karaktereket
        fogjuk tárolni (egyszerre ügye maximum 256ot). Inicializálunk két változót, az egyik a kulcs tömb
        bejárására a másik pedig a beolvasott bájtok számlálására szolgál. 
      </para>
      <para>
        <programlisting language = "c">
          <![CDATA[
          
          int kulcs_meret = strlen (argv[1]);
          strncpy (kulcs, argv[1], MAX_KULCS);
          
          while ((olvasott_bajtok = read (0, (void *) buffer, BUFFER_MERET)))
    {

      for (int i = 0; i < olvasott_bajtok; ++i)
	{

	  buffer[i] = buffer[i] ^ kulcs[kulcs_index];
	  kulcs_index = (kulcs_index + 1) % kulcs_meret;

	}

      write (1, buffer, olvasott_bajtok);
 
   
            ]]>
        </programlisting>

        A strlen() függvény visszaadja az argv[1] hosszát, azaz a második argumentumét ([1] = második) 
        tehát az általunk megadott kulcsét, amelyet el is mentünk a kulcs_meret változóba. Ezután a strncopy()
        függvénnyel a kulcs tömbünkbe másoljuk a parancssorban megadott kulcsunkat karakterenként (a kulcs
        ügye egy char tömb).
        
      </para>

      <para>
        <programlisting language = "c">
          <![CDATA[
         
          
          while ((olvasott_bajtok = read (0, (void *) buffer, BUFFER_MERET)))
          {

            for (int i = 0; i < olvasott_bajtok; ++i)
	              {

	                buffer[i] = buffer[i] ^ kulcs[kulcs_index];
	                kulcs_index = (kulcs_index + 1) % kulcs_meret;

	              }

             write (1, buffer, olvasott_bajtok);
            
           }
 
   
            ]]>
        </programlisting>

        A while ciklusunk addig fog tartani, amig a read() függvénynek van mit beolvasnia. Jelen esetben a buffer
        tömbbe fog beolvasni standard inputról (ez a 0) BUFFER_MERET-nyi, azaz 256 bájtot. Ezután egy belső
        ciklusban végigmegyünk a jelenlegi beolvasott bájtokon vagy ha úgy tetszik akkor a karakterek számán
        és a bufferben tárolt beolvasott szövegrészt összeexorozzuk a kulcs adott (a kulcs index adja meg hogy melyik) 
        karakterével. Ezután növeljük a kulcs indexét eggyel. A %kulcs_meret arra szolgál, hogy ha elérjük a kulcs méretét, azaz végét akkor a következő
        iterációban előről, 0-ról induljon a kulcs index. Végül pedig kiirjuk a buffer tartalmát (ami már
        ügye a titkos szöveg) a standard outputra. 

      </para>
      
    </section>        
    <section>
        <title>Java EXOR titkosító</title>
        <para>
            Írj egy EXOR titkosítót Java-ban!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/vajkone/prog1/blob/master/caesar/exortitkosito.java">https://github.com/vajkone/prog1/blob/master/caesar/exortitkosito.java </link>             
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
      <para>
        <programlisting language = "java">
          <![CDATA[
        import java.io.FileInputStream;
        import java.io.FileOutputStream;
        import java.io.IOException;
        import java.util.ArrayList;
        import java.util.Scanner;

        public class Main { 
          
        
          public static void main(String[] args) throws IOException {
          FileInputStream fin;
          FileOutputStream fout;

          fin=new FileInputStream("tiszta.txt");
          int c;
          ArrayList<Integer> input = new ArrayList<Integer>();
          ArrayList<Integer> output = new ArrayList<Integer>();
          Scanner in = new Scanner(System.in);
          System.out.println("Adja meg a kulcsot: ");
          String kulcs = in.nextLine();
          int kulcs_hossz = kulcs.length();

          while((c=fin.read())!=-1)
          {
              input.add(c);
          }
          fout = new FileOutputStream("titkos.txt");
          for(int i=0;i<input.size();i++)
          {
              output.add(input.get(i)^kulcs.charAt(i%kulcs_hossz));
              fout.write(output.get(i));
          }

          for(int i=0;i<output.size();i++)
          {
              System.out.printf("%c",output.get(i));
          }

          fin.close();
          fout.close();

        }
          
 
   
            ]]>
        </programlisting>
      </para>
        <para>
            Mivel a Java is C alapú nyelv ezért a program logikai felépitése szinte megegyezik az előzőjével. Érdemi változtatás
            ott történik részemről, hogy a titkositandó szöveget és kulcsot a main függvényünk most nem 
            parancssori argumentumként kapja meg (ennél a feladatnál windowsban dolgoztam és igy egyszerűbbnek éreztem)
            , hanem a kódba ágyazva adjuk át neki a tiszta szöveget (vagyis az elérési útját) 
            és a user a programot futtatva kap egy promptot ahol megadhatja a kulcsot. Ezután ugyancsak a 
            kódba ágyazva megadjuk az output file nevét és elérési útját (ha csak a nevét adjuk az is elég,
            ekkor a programunk src mappájába kerül automatikusan) és egy for loopban bájtonként beleirjuk a 
            titkositott szöveget. Ezek után még fontos, hogy lezárjuk az input és output streameket (amikkel
            file-okból olvastunk és file-okba irunk) különben előfordulhat, hogy például az output txt-nk
            üresen marad a program futása után. 
            
        </para> 
    </section>        
    <section>
        <title>C EXOR törő</title>
        <para>
            Írj egy olyan C programot, amely megtöri az első feladatban előállított titkos szövegeket!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://github.com/vajkone/prog1/blob/master/caesar/exortoro.c">https://github.com/vajkone/prog1/blob/master/caesar/exortoro.c</link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
      <para>
        Próbáljuk hát meg feltörni, a korábban elkészitett titkos szövegünket. Feltörés alatt a kulcs-ként
        megadott szó megfejtését kell érteni.
      </para>
      <para>
        <programlisting language = "c">
          <![CDATA[

          #define MAX_TITKOS 4096
          #define OLVASAS_BUFFER 256
          #define KULCS_MERET 8
          

          #include <stdio.h>
          #include <unistd.h>
          #include <string.h>
 
   
            ]]>
        </programlisting>
        
        Konstansok definiálása és könytárak hozzáadása a programunkhoz. Felmerülhet a kérdés hogy a 
        KULCS_MERET-et miért végelegsitjük 8-asnak? Nos igen, ez azt fogja feltételezni, hogy a titkositásnál
        8 karakternyi hosszú stringet adtunk meg kulcsként. Szóval a titkositónak muszáj kicsit segitenie
        minket azzal, hogy a "mi szabályaink" szerint játszik, ha azt szeretné, hogy a kódját feltörjük.
        
        
      </para>
      <para>
        <programlisting language = "c">
          <![CDATA[

        double atlagos_szohossz (const char *titkos, int titkos_meret)
        {
        int sz = 0;
        for (int i = 0; i < titkos_meret; ++i)
          if (titkos[i] == ' ')
          ++sz;

        return (double) titkos_meret / sz;
        }
 
   
            ]]>
        </programlisting>
        Ahogy neve is mutatja ez a függvény a titkositott bemenet szavainak átlagos hosszát fogja számolni.
        Ezt úgy teszi, hogy végigmegy a bemeneten és ha szóközhösz ér akkor, a szavak számlálására használt
        változót növeli eggyel. Végül az argumentumként átadott titkositott szöveg méretét elosztja a szavak
        számával. 

      </para>
      <para>
        <programlisting language = "c">
          <![CDATA[

      int tiszta_lehet (const char *titkos, int titkos_meret)
      {

        double szohossz = atlagos_szohossz (titkos, titkos_meret);

        return szohossz > 6.0 && szohossz < 9.0
          && strcasestr (titkos, "hogy") && strcasestr (titkos, "nem")
          && strcasestr (titkos, "az") && strcasestr (titkos, "ha");

      }
 
   
            ]]>
        </programlisting>
        Ez a függvény azt vizsgálja, hogy a dekódolt szöveg megfelel-e az alábbi követelményeknek:
        Az átlagos szóhossz 6 és 9 között van, valamint tartalmazza-e a "hogy" "nem" "az" "ha" szavakat.

      </para>
      <para>
        <programlisting language = "c">
          <![CDATA[
          
            void exor (const char kulcs[], int kulcs_meret, char titkos[], int titkos_meret)
            {

              int kulcs_index = 0;

              for (int i = 0; i < titkos_meret; ++i)
                {

                  titkos[i] = titkos[i] ^ kulcs[kulcs_index];
                  kulcs_index = (kulcs_index + 1) % kulcs_meret;

                }

            }
   
            ]]>
        </programlisting>
        Ez a függvény fogja megpróbálni a kód visszafejtését, melyekhez a program által generált lehetséges 
        kulcsokat fogja használni. Ha megfigyeljük, láthatjuk, hogy ez ugyanazt csinálja mint a titkositásnál
        használt pár sor, ez azért van mert ha valamit kétszer exorozunk akkor az eredeti szöveget kapjuk
        vissza, tehát egyszer exor=titkositott, kétszer exor=tiszta szöveg.

      </para>
      <para>
        <programlisting language = "c">
          <![CDATA[
          
           int exor_tores (const char kulcs[], int kulcs_meret, char titkos[],int titkos_meret)
	              
          {

            exor (kulcs, kulcs_meret, titkos, titkos_meret);

            return tiszta_lehet (titkos, titkos_meret);

          }

   
            ]]>
        </programlisting>
        Itt hivjuk meg a korábban bemutatott másik 2 függvényt. A return-ünk akkor lesz igaz 
        ha a tiszta_lehet függvénynek sikerült a visszafejtés.

      </para>
      <para>
        <programlisting language = "c">
          <![CDATA[
          
    while ((olvasott_bajtok = read (0, (void *) p, (p - titkos + OLVASAS_BUFFER <
		 MAX_TITKOS) ? OLVASAS_BUFFER : titkos + MAX_TITKOS - p)))
	  p += olvasott_bajtok;
		 
  for (int i = 0; i < MAX_TITKOS - (p - titkos); ++i)
    titkos[p - titkos + i] = '\0';

  
  for (int ii = '0'; ii <= '9'; ++ii)
    for (int ji = '0'; ji <= '9'; ++ji)
      for (int ki = '0'; ki <= '9'; ++ki)
	      for (int li = '0'; li <= '9'; ++li)
	        for (int mi = '0'; mi <= '9'; ++mi)
	          for (int ni = '0'; ni <= '9'; ++ni)
	            for (int oi = '0'; oi <= '9'; ++oi)
		            for (int pi = '0'; pi <= '9'; ++pi)
		              {
		                kulcs[0] = ii;
		                kulcs[1] = ji;
		                kulcs[2] = ki;
		                kulcs[3] = li;
		                kulcs[4] = mi;
		                kulcs[5] = ni;
		                kulcs[6] = oi;
		                kulcs[7] = pi;

		    if (exor_tores (kulcs, KULCS_MERET, titkos, p - titkos))
		      printf
			("Kulcs: [%c%c%c%c%c%c%c%c]\nTiszta szoveg: [%s]\n",
			 ii, ji, ki, li, mi, ni, oi, pi, titkos);

		     
		    exor (kulcs, KULCS_MERET, titkos, p - titkos);
		  }
   
            ]]>
        </programlisting>
        A main függvényünkön belül elkezdjük a bufferbe olvasni a dekódolandó szöveget, ha a szöveg végére
        érünk és a bufferben üres hely marad azokat töröljük. Ezután 8 egymásba ágyazott for ciklussal elkezdjük előállitani
        a kulcsot. A legbelső for ciklus végén meghivjuk az exor_tores-t és megvizsgáljuk, hogy a
        a kulcs amit találtunk jó-e, tehát megvizsgáljuk elsőnek a 00000000-t, majd 00000001-t 
        és igy tovább.
        Amint azt láthatjuk, a for ciklusok 0-tól 9-ig mennek, magyarul ez a program csak olyan
        kulcsot tud visszafejteni ami 8 darab számból áll.


      </para>
    </section>        
    <section>
        <title>Neurális OR, AND és EXOR kapu</title>
        <para>
            R
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Koyw6IH5ScQ">https://youtu.be/Koyw6IH5ScQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/NN_R</link>               
        </para>
      <para>
        Tutorom a megoldásban: Lovász Botond
      </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
      <para>
        A neuronok agyunk olyan idegsejtjei melyek elekromos potenciállal rendelkeznek és
        más sejtekkel speciális kapcsolatok, úgynevezet szinapszisok révén kommunikálnak.
        Mesterséges neuronnak azt a matematikai modelt nevezzük, amely a biológiai neuron képletét hivatott
        megadni (McCulloch és Pitts, 1943). A mesterséges neuronok alapvető elemei egy (mesterséges) neurális hálónak.
      </para>
      <para>
        A model megértéséhez először is fontos tudni, hogy egy neuron akkor "tüzel" ha a bemeneti értékek súlyozott
        összege meghalad egy bizonyos küszöböt. 
      </para>
      <para>
        Először is a programunkat meg kell tanitani az OR AND és EXOR logikai műveletek használatára, ez
        a programunkban igy fog kinézni:
        <programlisting language = "R">
        <![CDATA[
          
          a1    <- c(0,1,0,1)
          a2    <- c(0,0,1,1)
          OR    <- c(0,1,1,1)

          or.data <- data.frame(a1, a2, OR)
          
          a1    <- c(0,1,0,1)
          a2    <- c(0,0,1,1)
          OR    <- c(0,1,1,1)
          AND   <- c(0,0,0,1)

          orand.data <- data.frame(a1, a2, OR, AND)
          
          a1      <- c(0,1,0,1)
          a2      <- c(0,0,1,1)
          EXOR    <- c(0,1,1,0)

          exor.data <- data.frame(a1, a2, EXOR)
          nn.exor <- neuralnet(EXOR~a1+a2, exor.data, hidden=0, linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

          plot(nn.exor)

          compute(nn.exor, exor.data[,1:2])


            ]]>
      </programlisting>
        
        A compute fügvénynek átadjuk a betantott neurális hálót és az elején megadott adatokat, ami ezután
        kiszámolja a logikai műveletek eredményét. Ha ezt igy futtatjuk azt tapasztaljuk, hogy a program 
        nagyjából 50%-os pontossággal fog dolgozni, ami nem jobb mint a véletlenszerű találgatás. Ha viszont
        ún. rejtett neuronokat adunk hozzá, azaz növeljük a számukat (mert ügyebár a fenti programban
        is látható hogy van csak 0-ra van állitva), a program tanulékonysága drasztikusan megnő, ezzel növelve 
        a pontosságot is. Növeljük hát meg mind a rejtett neuronok rétegét mind a számukat: 
        
      </para>
      <para>
        
        <programlisting language = "R">
          <![CDATA[
          
          a1      <- c(0,1,0,1)
          a2      <- c(0,0,1,1)
          EXOR    <- c(0,1,1,0)

          exor.data <- data.frame(a1, a2, EXOR)

          nn.exor <- neuralnet(EXOR~a1+a2, exor.data, hidden=c(6, 4, 6), linear.output=FALSE, stepmax = 1e+07, threshold = 0.000001)

          plot(nn.exor)

          compute(nn.exor, exor.data[,1:2])



            ]]>
        </programlisting>

        Ezekkel az értékekkel futtatva a plot függvény ugyan sokkal bonyolultabb ábrát fog kirajzolni, 
        de a rejtett neuronaknak hála mostmár az EXOR műveletet is nagy pontossággal végzi el a program.

      </para>
    </section>        
    <section>
        <title>Hiba-visszaterjesztéses perceptron</title>
        <para>
            C++
        </para>
        <para>
            Megoldás videó:<link xlink:href="https://www.youtube.com/watch?v=XpBnR31BRJY">https://www.youtube.com/watch?v=XpBnR31BRJY</link>
        </para>
        <para>
            Megoldás forrása:<link xlink:href="https://github.com/nbatfai/nahshon/blob/master/ql.hpp#L64">https://github.com/nbatfai/nahshon/blob/master/ql.hpp#L64</link>                
        </para>
      <para>
        Tanulságok, tapasztalatok, magyarázat...
      </para>
      <para>
        A gépi tanulás területén, a perceptron egy olyan algoritmus melyet a bináris osztályozás területén használnak.
        A perceptron éppen úgy működik mint a neurális hálózatok, ahhoz hogy működjön, előbb
        be kell tanitani, meg kell neki mondani, hogy bizonyos dolgokat miről ismer fel és hogy a jövőben
        ezeket mi alapján osztályozza. A perceptronnak 4 fő része van, ezek:
      </para>
        <para>
          1: input értékek
        </para>
        <para>
          2: súlyozás
        </para>
        <para>
          3: össz súly
        </para>
        <para>
          4: osztályozás funkció
        </para>
      <para>
        Először is az inputokat meg kell szorozni a saját súlyukkal, ezután ezeket az értékekek összeadjuk amiből megkapjuk a
        súlyozott összeget, majd ezt az összeget betápláljuk a megfelelő funkcióba, ami ezután az inputokat osztályozza. Mint korábban
        emlitésre került, bináris osztályozásnál a funkciónak csak 2 osztály közül kell választania. Pl.: 0 és 1, sötét-világos, kutya-macska stb...
        
      </para>
                    
    </section>
  
  <section>

    <title> Gutenberg olvasónaplók</title>
    <para>


    </para>
  </section>
  
  <section>
    <title>Juhász István - MAGAS SZINTŐ PROGRAMOZÁSI NYELVEK 1 </title>
      
      
   
    <para>
      A számitógépek megjelenése lehetőve tette az emberi gondolkodás bizonyos elemeinek automatizálását.
      Ehhez viszont az embernek szüksége volt arra hogy a számitógépet programozni tudja. Ennek a kivitelézésre
      kailakult nyelveknek 3 szintjét különböztetjük meg. Az első a gépi nyelv ami valójában 0-k és 1-esek sorozata, azaz bináris kód.
      E fölött áll az assembly nyelv, ami félúton van gépi nyelv és emberi nyelv között. Ami pedig már "emberi fogyasztásra alkalmas"
      minősül, az pedig a magas szintű programozási nyelv azaz nyelvek merthogy mára már rengeteg van belőlük, viszont ez a könyv
      a korábbiak közül fog néhányra koncentrálni, azokon belűl is leginkább az ADA és C nyelveken lesz a fókusz.
      Az ezeken a nyelveken iródott programokat forrásprogramnak vagy forrásszövegnek nevezzük (angolul source-code), melyekre
      vonatkoznak bizonyos nyelvtani és formai szabályok - ezeket szintaktikai szabályoknak nevezzük. Egy nyelvre vonatkoznak ugyanakkor
      szemantikai szabályok is, ezek az értelmezési, tartalmi és jelentésbéli szabályok.
    </para>
  
  </section>
  
  <section>
    
    <title> Kernigen and Ritchie: A C programozási nyelv </title>
     
    
    <para>
      A könyv azzal a céllal iródott, hogy az olvasó a lehető leggyorsabban eljusson arra a pontra, 
      ahol már önállóan működő és használható programokat tud irni. A könyv irói feltételezik, hogy 
      az olvasó nem teljesen nulláról indul, volt már dolga számitógépekkel esetleg programozással is
      próbálkozott. Ez persze nem jelenti azt, hogy bármely fontos részt átugranának, csak szimplán a 
      szakzsargont nem részletezik. 
    </para>
    
    <para>
      A bevezető alapvető fogalmakra és tudnivalókra koncentrál: Változók
      és állandók, a C nyelv aritmetikája, input és output alapvető kezelése és az ezekhez kapcsolódó ismeretek,
      függvények, vezérlésátadás. A bevezetőbe nem kerültek bele a mutatók, struktúrák, a nyelv operátorkészletének
      java és valamennyi vezérlésátadó utasitás sem. Ezek tudatosan kerültek későbbi fejezetekbe, ugyanis
      ezek majd nagyobb és összetettebb programok irásánál lesznek elengedhetetlenek. Ez a megközelités
      természetsen jár néhány hátránnyal is, nevezetesen, hogy a a nyelv összetevőinek bemutatása valamelyest
      szétszórtan lesz megtalálható a könyvben és nem tudunk majd szükség esetén egy bizonyos fejezetre
      visszalapozni, ahol minden egyben van. 
    </para>
  
  </section>
  
  <section>
    <title>Benedek Zoltán - Levendovszky Tihamér: Szoftverfejlesztés C++ nyelven</title>
      
    
    <para>
      
      Ahogy a cim is mutatja C nyelvről váltunk C++-ra. Azért is fontos megjegyezni, hogy váltunk mert
      a könyv maga is gyakran a C-hez viszonyitva mutatja be a C++ nyelvet és azt, hogy az hol és hogyan
      változtat és javit rajta. Vitathatatlan, hogy a C++ előrelépés a C-hez képest, ahogy azt neve is
      viccesen mutatja, C csak inkrementálva. A C++ olyan változtatásokat vezet be mint az osztályok, ezért
      a C++ már egy objektum oriántált nyelv lesz. Megjelenik a boolean változó (true, false), melyet eddig
      ügye csak számok reprezentáltak. A könyv tárgyalja továbbá a refernciával történő paraméterátadást, 
      ahol a függvényen belül változtathatunk egy külső változó értékén. De szó esik a "Rule of 3" és "Rule
      of 5" -ról is mely szabályok az erőforrásgazdálkodásra vonatkoznak. A Rule of 3 például azt mondja ki
      hogy ha a destructor, copy constructor vagy copy assignment operator valamelyikét tartalmazza egy osztály
      akkor explicit módon mind a hármat érdemes definiálni.

    </para>
    
  </section>
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
