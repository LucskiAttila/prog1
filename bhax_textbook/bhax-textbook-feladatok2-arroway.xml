<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Arroway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>OO szemlélet</title>
      
        <para>

          A polártranszformációs generátor működésének az alapelgondolása a következő: Először is tárol egy logika változót és tud tárolni
          egy értéket. A logika változó értéke azt hivatott reprezentálni, hogy éppen van-e tárolt érték vagy nincs. Ha nincs tárolt érték
          akkor generálunk, de nem is egyet hanem rögtön két pseudo random számot. Az egyik a függvényünk visszatérési értéke lesz a másik pedig a tárolt
          érték, amit legközelebb már visszatudunk majd adni ha újabb avagy több random számra van szükségünk. Az algoritmus így néz ki: 

        </para>
      
      <para>
        <programlisting language = "Java">
          <![CDATA[
          
      public class PolarGenerator {

          private static boolean vanTarolt;
          private double taroltErtek;

          public PolarGenerator() {
              vanTarolt = false;

          }

          public double generate() {
              if (!vanTarolt)
              {
                  double u1, u2, v1, v2, w;

                  do{
                      u1 = random();
                      u2 = random();
                      v1 = 2 * u1 - 1;
                      v2 = 2 * u2 -1;
                      w = v1 * v1 + v2 * v2;
                  }
                  while (w > 1);

                  double r = Math.sqrt ((-2 * Math.log (w)) / w);

                  taroltErtek = r * v2;
                  vanTarolt = !vanTarolt;

                  return r * v1;
              }

              else
              {
                  vanTarolt = false;
                  return taroltErtek;
              }
          }

      }
   
           ]]>
        </programlisting>
        
      </para>

      <para>
        Ezután a main függvényünkben példányosítunk és futtatjuk, jelen esetben 15 random számot generálva.

        <programlisting language = "Java">
          <![CDATA[
          
          public static void main(String[] args) {
        
              for (int i=0;i<15;i++) {
                  PolarGenerator PolarGen = new PolarGenerator();
                  double random= PolarGen.generate();
                  System.out.println(random);
              }
        

          }
          
           ]]>
        </programlisting>

        <figure>
          <title>Futtatás eredménye</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="../Prog2Arroway/generate.png" format="PNG" scale="90"/>
            </imageobject>
          </mediaobject>
        </figure>
        
        
      </para>

      <para>
        A mi Polárgenerátorunk lényegében ugyanaz mint a Java nextGaussian() nevű függvénye. A hivatalos Oracle dokumentációban elolvashatjuk
        hogy ez is a "polar methodust" használja: "This uses the polar method of G. E. P. Box, M. E. Muller, and G. Marsaglia,
        as described by Donald E. Knuth in The Art of Computer Programming, Volume 3: Seminumerical Algorithms,
        section 3.4.1, subsection C, algorithm P. Note that it generates two independent values at the cost
        of only one call to StrictMath.log and one call to StrictMath.sqrt."

        <figure>
          <title>nextGaussian</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="../Prog2Arroway/nextGaussian.png" format="PNG" scale="70"/>
            </imageobject>
          </mediaobject>
        </figure>

      </para>
        
    </section>        

    <section>
        <title>Homokozó</title>
      
        <para>
          
        </para>
      <para>
        
      </para>
    </section>

  <section>
    <title>Gagyi</title>
  
    <para>

      Hogy megértsük, hogy hogyan is működik az Integer típus és hogy miért is érdekes ez a feladat, érdemes először is egy pillantást
      vetni az Integer osztály valueOf() nevű függvényének dokumentációjára:
<literallayout>

public static Integer valueOf(int i)

Returns an Integer instance representing the specified int value.
If a new Integer instance is not required, this method should
generally be used in preference to the constructor Integer(int),
as this method is likely to yield significantly better space and
time performance by caching frequently requested values.
This method will always cache values in the range -128 to 127,
inclusive, and may cache other values outside of this range. 
        
Parameters: 
i - an int value.
        
Returns:
an Integer instance representing i.
        
</literallayout>
      
      Láthatjuk hát, hogy amikor Integer objektumot hozunk létre akkor a -128-tól 127-ig intervallumban mindig egy cachelt poolból fogunk
      értéket kapni, tehát ha x-nek és t-nek is mondjuk 127-et adunk értékként, akkor mindkét változóhoz szimplán ugyanazt az objektumot
      rendeljük hozzá kétszer. Viszont ha ezeken az értékeken kívűl adunk x-nek és t-nek értéket (de továbbra is ugyanazt az értéket)
      akkor már nem ugyanazt az objektumot fogjuk hozzájuk rendelni, így a memóriacímük is eltérő lesz, ergó a t!=x feltétel teljesül
      és végtelen ciklusba lépünk.


    </para>

    <para>
      <programlisting language = "Java">
          <![CDATA[

      Integer x,t;

      Scanner sc = new Scanner(System.in);

      System.out.print("Value of x: ");
      x=sc.nextInt();

      System.out.print("Value of t: ");
      t=sc.nextInt();

      while (x <= t && x >= t && t != x){

      }
      
        ]]>
    </programlisting>


    </para>

    <para>

      <figure>
        <title>A t != x feltétel nem teljesül, a program futása véget ér</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../Prog2Arroway/nemvegtelen.png" format="PNG" scale="70"/>
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>A t != x feltétel ismét nem teljesül</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../Prog2Arroway/nemvegtelen2.png" format="PNG" scale="70"/>
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>A t != x feltétel teljesül, végtelen ciklusba lépünk</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../Prog2Arroway/vegtelen1.png" format="PNG" scale="70"/>
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>A t != x feltétel ismét teljesül</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../Prog2Arroway/vegtelen2.png" format="PNG" scale="70"/>
          </imageobject>
        </mediaobject>
      </figure>
      
    </para>
    
  </section>

  <section>
    <title>Yoda</title>

    <para>

      Ha láttuk már a Star Wars-t angolul akkor tudjuk, hogy Yoda elég furán beszéli az angolt, ugyanis egyfajta fordított szintaxist
      használ, ahol az igéket mindig a mondat végére teszi. A Yoda-conditions programozói stílus elnevezése innen származik.


      <figure>
        <title>Yoda syntax</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../Prog2Arroway/yoda.jpg" format="JPG" scale="70"/>
          </imageobject>
        </mediaobject>
      </figure>
      

    </para>

    <para>
      Tehát követve a Yoda-conditions, a lényeg hogy egy if összehasonlításnál például egy konstans-t helyezünk első helyre ezzel kikerülve
      azt hogy NullPointerException-t kapjunk. Íme egy példa ahol ezt nem tartjuk be (szerencsére az IDE-k többsége mára már van annyira
      okos, hogy az ilyen hibákat már futás előtt is észreveszik és jelzi a felhasználónak hogy itt bizony az equals() függvény NullPointerExceptiont
      fog dobni):

      <figure>
        <title>Non-Yoda conditions</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../Prog2Arroway/noyoda.png" format="PNG" scale="90"/>
          </imageobject>
        </mediaobject>
      </figure>

      Nézzük meg hogy ha mindenképp szeretnénk egy Stringet, melynek értéke null, valamivel összehasonlítani akkor azt hogyan tehetjük meg
      Yoda bölcsességét felhasználva.

      <figure>
        <title>Yoda condition-t használva</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../Prog2Arroway/yodaworks.png" format="PNG" scale="90"/>
          </imageobject>
        </mediaobject>
      </figure>
      
    </para>

  </section>

  <section>
    <title>Kódolás from scratch</title>

    <para>

      A feladat leírása szerint a <link xlink:href="https://www.davidhbailey.com//dhbpapers/bbp-alg.pdf">https://www.davidhbailey.com//dhbpapers/bbp-alg.pdf</link> folyóiratból kiindulva
      kellett a BBP algoritmust Java nyelven megírni, amely a Pi hexa számjegyeit hívatott kiszámolni. A feladat megoldása igényelt egy bizonyos
      szintű matematika háttértudást, aminek sajnos én nem voltam teljességel birtokában ezért

      <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html#pi_jegyei">ebből</link> a forrásból indulva
      dolgoztam és próbáltam a problémát reverse engineering jeleggel értelmezni. Maga az algoritmus így néz ki:

      <programlisting language = "Java">
          <![CDATA[
          
     class PiBBP {

        private String d16PiHexaJegyek;

        private PiBBP(int d) {

        double d16Pi;

        double d16S1t = d16Sj(d, 1);
        double d16S4t = d16Sj(d, 4);
        double d16S5t = d16Sj(d, 5);
        double d16S6t = d16Sj(d, 6);

        d16Pi = (4.0d * d16S1t) - (2.0d * d16S4t) - d16S5t - d16S6t;

        d16Pi -= StrictMath.floor(d16Pi);

        StringBuilder sb = new StringBuilder();

        Character[] hexaJegyek = {'A', 'B', 'C', 'D', 'E', 'F'};

        while(d16Pi != 0.0d) {

            int jegy = (int)StrictMath.floor(16.0d*d16Pi);

            if(jegy<10)
                sb.append(jegy);
            else
                sb.append(hexaJegyek[jegy-10]);

            d16Pi = (16.0d*d16Pi) - StrictMath.floor(16.0d*d16Pi);
        }

        d16PiHexaJegyek = sb.toString();
    }

    private double d16Sj(int d, int j) {

        double d16Sj = 0.0d;

        for(int k=0; k<=d; ++k)
            d16Sj += (double)n16modk(d-k, 8*k + j) / (double)(8*k + j);

        return d16Sj - StrictMath.floor(d16Sj);
    }

    private long n16modk(int n, int k) {

        int t = 1;
        while(t <= n)
            t *= 2;

        long r = 1;

        while(true) {

            if(n >= t) {
                r = (16*r) % k;
                n = n - t;
            }

            t = t/2;

            if(t < 1)
                break;

            r = (r*r) % k;

        }

        return r;
    }



      

        ]]>
      </programlisting>

      Ezután a main függvényünkben a new kulcsszóval példányosítjuk a PiBPP nevezetű objektumunkat és egyúttal ki is íratjuk a Pi szám 1000001. jegyétől következő néhány
      számot hexadecimális formában:

      <programlisting language = "Java">
          <![CDATA[
          
          public static void main(String[] args) {
          
              System.out.print(new PiBBP(1000000));
          }
          
          ]]>
        </programlisting>
      
      Amelyre a következőt outputot kapjuk: 

    <figure>
      <title>Futtatás eredménye</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="../Prog2Arroway/pibbp.png" format="PNG" scale="120"/>
        </imageobject>
      </mediaobject>
    </figure>





      </para>

  </section>


</chapter>                
